<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Loco.Engineering Decoder Settings</title>

    <link rel="stylesheet" href="./base-min.css">
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="./grids-min.css">
    <link rel="stylesheet" href="./grids-responsive-min.css">
    <script type="module" src="./action-modal.js"></script>
    <script type="module" src="./storage.js"></script>

</head>

<body>
    <h1>Wireless Command Control (WCC)/SimpleDCC Decoder Settings</h1>

    <div class="wifi_set_cont">
        <h3 class="section_header">Settings</h3>
        <p class="section_hint">Type in a decoder DCC address that you want to use with this decoder.
            It should be the same address as you use to send DCC commands from your command station to this decoder. For
            example, 2 or 5 or 110, etc. This address will be used to filter DCC packets received by the decoder.
            <br>
            <br>
            If you don't use DCC or want to see all DCC packets in the list below, leave this field empty.
        </p>
        <input type="text" id="ssid" placeholder="Decoder address, for example, 2 or 5 or 122 etc">
        <div style="display: flex; width:300px; margin: auto;"><button id="s_wifi" class="s_wifi">Save</button>
        <button id="s_wifi" class="s_wifi">Hide</button></div>
    </div>

    <div class="wifi_set_cont">
        <h3 class="section_header">States<button id="new_action_btn" class="new_btn">Add state</button>
        </h3>

        <p class="section_hint">What the decoder should do when a particular DCC packet or WCC message is received</p>
        <div class="tableFixHead">

            <table id="dcc_packets" class="common_table">
                <thead>
                    <tr>
                        <th width="40">ADDRESS</th>
                        <th width="100">TYPE</th>
                        <th>DESCRIPTION</th>
                        <th width="100">RAW PACKET</th>
                        <th width="80"></th>
                    </tr>
                </thead>
                <tbody>
                </tbody>

            </table>
        </div>
    </div>

    <div class="wifi_set_cont">
        <h3 class="section_header">DCC packets</h3>
        <p class="section_hint">DCC packets filtered by the decoder address or all DCC packets received by the decoder
            if the decoder address isn't specified</p>

        <div class="tableFixHead" id="dcc_packets_table_container">

            <table id="dcc_packets_table" class="common_table">
                <thead>
                    <tr>
                        <th width="40">ADDRESS</th>
                        <th width="100">TYPE</th>
                        <th>DESCRIPTION</th>
                        <th width="100">RAW PACKET</th>
                        <th width="80"></th>
                    </tr>
                </thead>
                <tbody id="dcc_packets_tbody">
                </tbody>

            </table>
            <p class="no_data_hint" id="no_dcc_packets_hint">No DCC packets received yet</p>

        </div>
    </div>


    <div class="wifi_set_cont">
        <h3 class="section_header">WCC events</h3>
        <p class="section_hint">Messages received from other decoders over WCC protocol</p>

        <div class="tableFixHead">

            <table id="dcc_packets" class="common_table">
                <thead>
                    <tr>
                        <th width="40">ADDRESS</th>
                        <th width="100">TYPE</th>
                        <th>DESCRIPTION</th>
                        <th width="100">RAW PACKET</th>
                        <th width="80"></th>
                    </tr>
                </thead>
                <tbody>
                </tbody>

            </table>
        </div>

        <action-modal></action-modal>

    </div>

    <script type="module">
        import { show_new_action } from "./action-modal.js";
        import { set_decoder_id, load_local_project, add_state } from "./storage.js";

        set_decoder_id("some_id"); //Replace with decoder mac address
        load_local_project();
        //var gateway = `ws://${window.location.hostname}/ws`;
        var gateway = `ws://192.168.4.1/ws`;

        var websocket;
        window.addEventListener('load', onLoad);
        function initWebSocket() {
            console.log('Trying to open a WebSocket connection...');
            websocket = new WebSocket(gateway);
            websocket.onopen = onOpen;
            websocket.onclose = onClose;
            websocket.onmessage = onMessage;
        }
        function onOpen(event) {
            console.log('Connection opened');
        }
        function onClose(event) {
            console.log('Connection closed');
            setTimeout(initWebSocket, 2000);
        }
        async function onMessage(event) {

            const buffer = new Uint8Array(await event.data.arrayBuffer());
            console.log("New message " + buffer.length);

            //Parse the message from a decoder
            //Get a type
            var msg_index = 0;
            let msg_type = buffer[msg_index++];

            if (msg_type == 4) {
                //This a message with DCC packets
                //Get the amount of DCC packets
                let dcc_packets_amount = buffer[msg_index++];
                for (var i = 0; i < dcc_packets_amount; i++) {
                    let packet_type = buffer[msg_index++];
                    var packet_type_str = "Unknown";
                    var description_str = "";

                    let adr_1 = buffer[msg_index++];
                    let adr_2 = buffer[msg_index++];

                    let address = (((adr_2 & 0xFF) << 8) | (adr_1 & 0xFF));
                    let raw_packet_length = buffer[msg_index++];

                    var raw_packet = [];
                    var raw_packet_str = "";

                    for (var k = 0; k < raw_packet_length; k++) {
                        raw_packet[k] = buffer[msg_index++];
                        raw_packet_str += toBinString(Uint8Array.from([raw_packet[k]])) + " ";
                    }

                    let user_data_length = buffer[msg_index++];

                    var user_data = [];
                    for (var k = 0; k < user_data_length; k++) {
                        user_data[k] = buffer[msg_index++];

                    }

                    switch (packet_type) {
                        case 0:
                            description_str = "No description available";
                            address = "-";
                            break;
                        case 1:
                            packet_type_str = "Speed";
                            description_str = `Speed: ${user_data[0]} | Steps: ${user_data[2]} | Dir: ${user_data[1] ? 'Forward' : 'Reverse'}`
                            break;
                        case 2:
                            packet_type_str = "Function";
                            //Get the function group
                            var function_group_str = "0 - 4";
                            switch (user_data[0]) {
                                case 2:
                                    function_group_str = "5 - 8";
                                    break;
                                case 3:
                                    function_group_str = "9 - 12";
                                    break;
                                case 4:
                                    function_group_str = "13 - 20";
                                    break;
                                case 5:
                                    function_group_str = "21 - 28";
                                    break;
                                default:
                                    break;
                            }
                            description_str = `Function Group: ${function_group_str} | Steps: ${user_data[2]} | Dir: ${user_data[1] ? 'Forward' : 'Reverse'}`
                            break;
                        default:
                            break;
                    }

                    //Add a cell to the DCC packets list
                    var tr_node = document.createElement('tr');
                    tr_node.classList.add("service_cell");
                    tr_node.innerHTML = `<td>${address}</td><td>${packet_type_str}</td><td>${description_str}</td><td>${raw_packet_str}</td><td><button id="table_btn" class="table_btn">Add action</button></td>`;

                    document.querySelector('#dcc_packets_tbody').appendChild(tr_node);


                }

            }

            document.querySelector('#no_dcc_packets_hint').style.display = "none";

            //Autoscoll
            //let dcc_packets_table_el = document.querySelector('#dcc_packets_table_container');
            //dcc_packets_table_el.scrollTop = dcc_packets_table_el.scrollHeight;

        }
        function onLoad(event) {
            initWebSocket();
            initButton();
        }
        function initButton() {
            document.getElementById('s_wifi').addEventListener('click', connectToWiFi);
        }
        function connectToWiFi() {
            let ssid = document.getElementById('ssid').value;
            let passwd = document.getElementById('passwd').value;
            let msg_ind = 0;
            var wf_set = [];
            wf_set[msg_ind++] = 2; //message type
            wf_set[msg_ind++] = ssid.length; // ssid length
            for (let i = 0; i < ssid.length; ++i) {
                wf_set[msg_ind++] = ssid.charCodeAt(i);
            }
            wf_set[msg_ind++] = passwd.length; // passwd length
            for (let i = 0; i < passwd.length; ++i) {
                wf_set[msg_ind++] = passwd.charCodeAt(i);
            }
            let msg = new Uint8Array(wf_set);
            console.log(msg);
            websocket.send(msg);
        }

        document.getElementById("new_action_btn").onclick = () => {
                show_new_action();
            };

        const toBinString = (bytes) =>
            bytes.reduce((str, byte) => str + byte.toString(2).padStart(8, '0'), '');
    </script>
</body>

</html>